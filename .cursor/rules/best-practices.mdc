---
description: 
globs: 
alwaysApply: true
---
---
description: 
globs: 
alwaysApply: true
---
description: Best Practices

ğŸ§  GENERAL PRINCIPLES
1. Write the code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. Prioritise readability over cleverness â€” use descriptive variable and function names.

2. Comment why, not what â€” assume the code explains itself, document intent or non-obvious decisions.

3. Follow DRY (Don't Repeat Yourself), KISS (Keep It Simple, Stupid), and YAGNI (You Ainâ€™t Gonna Need It) principles.

4. Error-first thinking â€” proactively handle edge cases, unexpected inputs, and failures.

ğŸ“¦ STRUCTURE & ORGANISATION
5. Use consistent project structures based on language/framework conventions (e.g., src/, tests/, utils/, services/).

6. Modularise code â€” functions and classes should do one thing and do it well.

7. Use environment-based configuration (e.g., .env, config files) â€” no hardcoded secrets or constants.

8. Separate concerns â€” donâ€™t mix business logic with UI, DB access, or validation.

ğŸ§ª TESTING
9. Write unit tests for all core logic â€” aim for 80%+ coverage on critical paths.

10. Use mocks/stubs for external APIs and I/O in tests.

11. Include test setup and teardown to isolate test behaviour.

12. Use snapshot testing for UI where appropriate (e.g., Jest + React).

ğŸ”„ VERSION CONTROL
13. Follow conventional commit messages (feat:, fix:, chore:).

14. Create focused pull requests with concise descriptions of what/why.

15. Always link PRs to tasks/tickets/issues where applicable.

ğŸ” SECURITY
16. Validate all user inputs â€” never trust client-side data.

17. Sanitise inputs and escape outputs (especially in SQL, HTML, JSON).

18. Use HTTPS, secure headers, and up-to-date packages.

19. Avoid storing passwords manually â€” use hashing with salts or external auth providers.

ğŸš€ PERFORMANCE & SCALABILITY
20. Optimise for performance after correctness â€” profile before micro-optimising.

21. Lazy load heavy components or assets when possible.

22. Paginate large datasets and stream responses if needed.

23. Implement caching (memory or CDN) for expensive operations or repeat requests.

ğŸ› ï¸ TOOLING & DEPENDENCIES
24. Use linters and formatters (e.g., ESLint, Prettier, Black) and enforce them via CI.

25. Avoid unnecessary dependencies â€” prefer native APIs or stable libraries. Pin package versions for reproducible builds unless using lockfiles.

ğŸ¤– AI-SPECIFIC INSTRUCTIONS
26. Default to language idioms and current community standards (e.g., use async/await in JavaScript).

27. When generating code, always include:

28. Clear function/class purpose

29. Input/output types or expectations

30. Basic usage example or test

31. Highlight any limitations or assumptions in the code for developers to review.

ğŸŒ FRONTEND-SPECIFIC
32. Use component-driven development (especially with frameworks like React, Vue, Flutter).

33. Leverage state management wisely â€” avoid overengineering with Redux unless necessary.

34. Use semantic HTML and accessibility best practices (ARIA, alt texts).

35. Ensure responsive and mobile-first design.

ğŸ”™ BACKEND-SPECIFIC
36. Follow RESTful conventions (or GraphQL where needed).

37. Design APIs with versioning and rate-limiting in mind.

38. Log meaningful events â€” not just errors but also key actions.

39. Ensure graceful failure and retries for integrations.


